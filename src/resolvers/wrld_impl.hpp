#ifndef OPENOBL_WRLD_IMPL_HPP
#define OPENOBL_WRLD_IMPL_HPP

#include "atmosphere.hpp"
#include "job/job.hpp"
#include "math/conversions.hpp"
#include "resolvers/wrld_resolver.hpp"
#include <OgrePrerequisites.h>
#include <Terrain/OgreTerrainGroup.h>

namespace oo {

// C++20: Use autogenerated <=>, hopefully
template<class T> struct IndexComp {
  bool operator()(const T &a, const T &b) const noexcept {
    return qvm::X(a) < qvm::X(b)
        || (qvm::X(a) == qvm::X(b) && qvm::Y(a) < qvm::Y(b));
  }
};

struct DistantChunk {
  Ogre::SceneNode *node;
  Ogre::MaterialPtr matPtr;
  DistantChunk(Ogre::SceneNode *pNode, Ogre::MaterialPtr pMatPtr) noexcept
      : node(pNode), matPtr(std::move(pMatPtr)) {}
};

struct WaterEntry {
  Ogre::SceneNode *node;
  Ogre::InstancedEntity *entity;
  WaterEntry(Ogre::SceneNode *pNode, Ogre::InstancedEntity *pEntity) noexcept
      : node(pNode), entity(pEntity) {}
};

class World::WorldImpl {
 public:
  using Resolvers = World::Resolvers;
  using PhysicsWorld = World::PhysicsWorld;

  explicit WorldImpl(oo::BaseId baseId, std::string name, Resolvers resolvers);
  ~WorldImpl();

  gsl::not_null<Ogre::SceneManager *> getSceneManager() const;
  gsl::not_null<PhysicsWorld *> getPhysicsWorld() const;

  oo::BaseId getBaseId() const;
  std::string getName() const;
  void setName(std::string name);

  /// Load the OGRE terrain at the given coordinates.
  /// If `async` is true then this returns immediately with an `oo::JobCounter`
  /// which will reach zero when the terrain is loaded, otherwise the terrain is
  /// loaded synchronously and this function returns `nullptr` when the loading
  /// is complete.
  std::shared_ptr<oo::JobCounter>
  loadTerrain(CellIndex index, bool async = true);

  /// Unload the OGRE terrain at the given coordinates.
  void unloadTerrain(CellIndex index);

  void loadTerrain(oo::ExteriorCell &cell);
  void unloadTerrain(oo::ExteriorCell &cell);

  void loadTerrain(oo::BaseId cellId, bool async = true);
  void unloadTerrain(oo::BaseId cellId);

  void updateAtmosphere(const oo::chrono::minutes &time);

 private:
  constexpr static const char *CHUNK_BASE_MATERIAL{
      "__LandscapeMaterialDistant"
  };
  constexpr static const char *WATER_MESH_NAME{"__WaterMesh"};
  constexpr static const char *WATER_MANAGER_BASE_NAME{"__WaterManager"};
  constexpr static const char *WATER_BASE_MATERIAL{"__WaterMaterial"};
  constexpr static uint8_t WATER_RENDER_QUEUE_GROUP{
      Ogre::RenderQueueGroupID::RENDER_QUEUE_9
  };

  using SceneManagerDeleter = std::function<void(Ogre::SceneManager *)>;

  using ChunkIndexCmp = IndexComp<ChunkIndex>;
  using CellIndexCmp = IndexComp<CellIndex>;

  using DistantChunkMap = std::map<ChunkIndex, DistantChunk, ChunkIndexCmp>;
  using WaterEntryMap = std::map<CellIndex, WaterEntry, CellIndexCmp>;

  using ImportDataArray = std::array<Ogre::Terrain::ImportData, 4u>;

  /// Opacity of the layer at each point in a quadrant.
  using QuadrantBlendMap = std::array<uint8_t,
                                      oo::verticesPerQuad<std::size_t>
                                          * oo::verticesPerQuad<std::size_t>>;

  /// Ordering of layers in a quadrant or in a cell, depending on context.
  using LayerOrder = std::vector<oo::BaseId>;

  /// Map taking each LTEX id to a blend map, for a fixed quadrant.
  /// \remark Access via [] will value-initialize any id which doesn't exist,
  ///         giving a transparent QuadrantBlendMap.
  using LayerMap = std::unordered_map<oo::BaseId, QuadrantBlendMap>;

  using LayerMaps = std::array<LayerMap, 4u>;
  using LayerOrders = std::array<LayerOrder, 4u>;

  tl::optional<const record::CELL &> getCell(oo::BaseId cellId) const;

  std::shared_ptr<oo::JobCounter> loadTerrainAsyncImpl(CellIndex index);
  std::shared_ptr<oo::JobCounter> loadTerrainSyncImpl(CellIndex index);

  std::array<Ogre::Terrain *, 4u> getTerrainQuads(CellIndex index) const;

  // \pre Called on render thread
  bool isTerrainLoaded(CellIndex index) const noexcept;

  /// Set up the default `Ogre::Terrain::ImportData` for our
  /// `Ogre::TerrainGroup`.
  /// `Ogre::TerrainGroup` provides a convenient `getDefaultImportSettings()`
  /// method to obtain an `Ogre::Terrain::ImportData` with customizable
  /// defaults, which should be preferred to default-constructing an
  /// `Ogre::Terrain::ImportData` and populating it manually.
  void setDefaultImportData();

  tl::optional<oo::BaseId> getLandId(oo::BaseId cellId) const noexcept;
  tl::optional<oo::BaseId> getLandId(oo::BaseId cellId,
                                     oo::BaseId wrldId) const noexcept;

  tl::optional<oo::BaseId> getWatrId() const noexcept;
  tl::optional<oo::BaseId> getWatrId(oo::BaseId wrldId) const noexcept;

  oo::BaseId getAncestorWrldId() const noexcept;
  oo::BaseId getAncestorWrldId(oo::BaseId wrldId) const noexcept;

  void makeWaterPlane() const;
  Ogre::MaterialPtr makeWaterMaterial() const;
  void makeWaterInstanceManager() const;

  void loadWaterPlane(CellIndex index, const record::CELL &cellRec);
  void unloadWaterPlane(CellIndex index);

  DistantChunk makeChunk(oo::ChunkIndex chunkIndex);
  void makeDistantCellGrid();

  void makeCellGrid();
  void makePhysicsWorld();

  void setTerrainHeights(ImportDataArray &importData,
                         const record::raw::VHGT &rec) const;

  void emplaceTexture(Ogre::StringVector &list, std::string texName) const;

  void writeNormals(Ogre::PixelBox dst, const record::LAND &rec) const;
  void writeVertexColors(Ogre::PixelBox dst, const record::LAND &rec) const;

  LayerMaps makeDefaultLayerMaps() const;
  LayerOrders makeDefaultLayerOrders() const;

  void applyBaseLayers(LayerMaps &layerMaps, const record::LAND &rec) const;
  void applyBaseLayers(LayerOrders &layerOrders, const record::LAND &rec) const;

  void applyFineLayers(LayerMaps &layerMaps, const record::LAND &rec) const;
  void applyFineLayers(LayerOrders &layerOrders, const record::LAND &rec) const;

  /// \remark `layerMap` is taken by nonconst ref so `[]` can be used to create
  ///         an empty quadrant blend map if one doesn't exist.
  void applyLayerMap(Ogre::Terrain *quad,
                     LayerMap &layerMap,
                     const LayerOrder &layerOrder) const;

  void blitNormals(const std::string &matName,
                   Ogre::PixelBox src,
                   Ogre::Box region) const;
  void blitVertexColors(const std::string &matName,
                        Ogre::PixelBox src,
                        Ogre::Box region) const;

  void blit(Ogre::Terrain *quad,
            LayerMap &layerMap,
            const LayerOrder &layerOrder,
            Ogre::PixelBox normals,
            Ogre::PixelBox vertexColors,
            Ogre::Box region) const;

  oo::BaseId mBaseId{};
  std::string mName{};
  Resolvers mResolvers;
  std::unique_ptr<Ogre::SceneManager, SceneManagerDeleter> mScnMgr;
  std::unique_ptr<PhysicsWorld> mPhysicsWorld;
  Ogre::TerrainGroup mTerrainGroup;
  oo::Atmosphere mAtmosphere;
  DistantChunkMap mDistantChunks{ChunkIndexCmp{}};
  WaterEntryMap mWaterPlanes{CellIndexCmp{}};
};

} // namespace oo

#endif // OPENOBL_WRLD_IMPL_HPP
